
# Вимоги та План Реалізації для Nenio - Розподіленої Системи Контролю Версій

## Вимоги

### Загальні Вимоги:
1. **Кросплатформеність**: Nenio має працювати на всіх основних операційних системах (Linux, Windows, macOS).
2. **Ефективність**: Оптимізація для швидкості роботи та мінімального використання пам’яті.
3. **Розподілений Характер**: Підтримка розподіленої співпраці без необхідності центрального сервера.
4. **Цілісність Даних**: Використання криптографічного хешування (наприклад, BLAKE3) для забезпечення цілісності даних.
5. **Версіонування**: Повний трекінг історії зі створенням гілок і об’єднань (merge).
6. **Модульний Дизайн**: Можливість майбутніх розширень без впливу на основну функціональність.
7. **Простий CLI-Інтерфейс**: Інтуїтивні команди для базових та розширених операцій.
8. **Синхронізація**: Надійний механізм синхронізації у форматі peer-to-peer.
9. **Дельта Стиснення**: Зберігання лише відмінностей (дельт) між версіями файлів для економії місця.

### Технічні Вимоги:
1. Мова Програмування: **Go** (для високої продуктивності та роботи з паралелізмом).
2. Зберігання: Комбінація файлового зберігання (blobs) та індексації метаданих (наприклад, SQLite або кастомний індекс).
3. Комунікація: gRPC для ефективної комунікації між клієнтом і сервером.
4. Тестування: Всеосяжне модульне та інтеграційне тестування кожного модуля.
5. Документація: Зрозуміла документація для користувачів і розробників.

---

## План Реалізації

### 1. Ініціалізація
- **Команда**: `nenio init`
- **Опис**: Створює новий репозиторій у поточній директорії з `.nenio` папкою, що містить метадані та об’єкти зберігання.
- **Завдання**:
  - Створити директорію `.nenio/objects` для blobs і дельт.
  - Створити `.nenio/refs` для гілок і тегів.
  - Згенерувати початковий файл конфігурації.

### 2. Управління Об’єктами
- **Компоненти**:
  - **Blob Storage**: Зберігання файлів як об’єктів з хешами.
  - **Tree Objects**: Представлення структури файлів і директорій.
  - **Commit Objects**: Представлення змін і посилання на батьківські коміти.
- **Завдання**:
  - Реалізувати хешування на основі BLAKE3.
  - Створити модульні функції для створення та отримання об’єктів.
  - Реалізувати дельта-стиснення для економії місця.

### 3. Версіонування
- **Можливості**:
  - Відстеження змін у файлах.
  - Підтримка гілок і об’єднань (merge).
- **Завдання**:
  - Розробити команду `commit` для створення нових версій.
  - Реалізувати логіку гілок (`branch`, `checkout`).
  - Створити систему вирішення конфліктів під час об’єднання.

### 4. Синхронізація
- **Можливості**:
  - Синхронізація у форматі peer-to-peer без центрального сервера.
- **Завдання**:
  - Реалізувати команди `pull` і `push` за допомогою gRPC.
  - Додати механізм вирішення конфліктів під час синхронізації.

### 5. CLI Інтерфейс
- **Опис**: Надати користувачам інтуїтивно зрозумілий командний інтерфейс.
- **Команди**:
  - `nenio add`: Додати файли для коміту.
  - `nenio commit`: Створити новий коміт.
  - `nenio log`: Показати історію комітів.
  - `nenio diff`: Показати відмінності між версіями.
  - `nenio push/pull`: Синхронізуватися з іншими вузлами.

### 6. Тестування
- **Завдання**:
  - Написати модульні тести для кожного модуля.
  - Реалізувати наскрізне тестування основних робочих сценаріїв.
  - Використовувати бенчмарки для забезпечення продуктивності.

### 7. Документація
- **Завдання**:
  - Створити документацію користувача з прикладами для кожної команди.
  - Написати документацію для розробників.

---

## Майбутні Покращення
1. **Графічний Інтерфейс (GUI)**: Розробка десктопного застосунку для зручного управління.
2. **Інтеграція**: Додати плагіни для IDE (наприклад, VSCode, IntelliJ).
3. **Розширені Функції**:
   - Хуки для виконання кастомних дій під час комітів чи об’єднань.
   - Підтримка великих бінарних файлів із можливістю використання хмарного сховища.
